esphome:
  name: esphome-vevor
  friendly_name: "Vevor Diesel Heater Controller"
  includes:
    - vevor_bus.h
    - vevor_bus.cpp

esp32:
  board: esp32dev
  framework:
    type: esp-idf

logger:
  level: INFO
  baud_rate: 115200

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  fast_connect: true
  power_save_mode: none
  min_auth_mode: WPA2

api:
  password: ""

ota:
  platform: esphome

web_server:
  port: 80

output:
  - platform: gpio
    id: vevor_tx_reserve
    pin: 17
    inverted: false

  - platform: gpio
    id: heater_status_led
    pin: 15
    inverted: false

globals:
  - id: last_heater_action
    type: int
    restore_value: true
    initial_value: '0'

  - id: heater_cooldown_duration
    type: uint32_t
    restore_value: true
    initial_value: '180000'

  - id: room_temp_cached
    type: float
    restore_value: false
    initial_value: 'NAN'

  - id: one_shot_bit2
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: original_bit2_state
    type: bool
    restore_value: false
    initial_value: 'false'

  - id: one_shot_bit1
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: original_bit1_state
    type: bool
    restore_value: false
    initial_value: 'false'

  - id: last_comms_time
    type: uint32_t
    restore_value: false
    initial_value: '0'
  - id: last_heater_comms_time
    type: uint32_t
    restore_value: false
    initial_value: '0'

  - id: heater_idle_status
    type: bool
    restore_value: false
    initial_value: 'true'

  - id: heater_power_level
    type: int
    restore_value: false
    initial_value: '0'

  - id: heater_power_letter
    type: std::string
    restore_value: false
    initial_value: '"N/A"'

  - id: vevor_init_flag
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: last_16bit_value
    type: uint16_t
    restore_value: false
    initial_value: '0'
  - id: last_8bit_value
    type: uint8_t
    restore_value: false
    initial_value: '0'
  - id: auto_tx_active
    type: bool
    restore_value: true
    initial_value: 'false'
  - id: last_8bit_timestamp
    type: std::string
    restore_value: false
    initial_value: '"N/A"'
  - id: last_16bit_timestamp
    type: std::string
    restore_value: false
    initial_value: '"N/A"'
  - id: auto_tx_interval
    type: float
    restore_value: true
    initial_value: '1.0'
  - id: boot_time
    type: std::string
    restore_value: false
    initial_value: '"N/A"'
  - id: led_heater_on
    type: bool
    restore_value: false
    initial_value: 'false'

  - id: heater_cooldown_active
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: heater_cooldown_start
    type: uint32_t
    restore_value: false
    initial_value: '0'
  - id: heater_last_toggle_time
    type: uint32_t
    restore_value: false
    initial_value: '0'

  - id: heater_runtime_start
    type: uint32_t
    restore_value: false
    initial_value: '0'
  - id: heater_total_runtime
    type: uint32_t
    restore_value: true
    initial_value: '0'
  - id: heater_last_runtime
    type: uint32_t
    restore_value: false
    initial_value: '0'

  - id: heater_waiting_for_idle
    type: bool
    restore_value: false
    initial_value: 'false'

  - id: boot_completed
    type: bool
    restore_value: false
    initial_value: 'false'

interval:
  - interval: 2s
    then:
      - lambda: |-
          if (!id(vevor_init_flag)) {
            ESP_LOGI("main", "Initialize VevorBus RMT (2s delayed)...");
            vevor_init();
            vevor_set_receive_callback([](uint8_t b, uint16_t val) {
              if (b != 0) {
                id(last_comms_time) = millis();
                if (b != id(last_8bit_value)) {
                  id(last_8bit_value) = b;

                  uint32_t uptime_seconds = millis() / 1000;
                  char uptime_str[25];
                  snprintf(uptime_str, sizeof(uptime_str), "Uptime: %02lu:%02lu:%02lu",
                           uptime_seconds / 3600, (uptime_seconds % 3600) / 60, uptime_seconds % 60);
                  id(last_8bit_timestamp) = std::string(uptime_str);
                }
              }
              if (val != 0) {
                id(last_heater_comms_time) = millis();
                if (val != id(last_16bit_value)) {
                  id(last_16bit_value) = val;

                  if ((val & 0xFFF0) == 0x9FF0 || val == 0xfa6c || val == 0x7ffd || (val & 0xF000) == 0x7000) {
                    id(heater_idle_status) = true;
                    id(heater_power_level) = 0;
                    id(heater_power_letter) = "N/A";
                    id(led_heater_on) = false;

                    if (id(heater_runtime_start) != 0) {
                      id(heater_last_runtime) = millis() - id(heater_runtime_start);
                      id(heater_total_runtime) += id(heater_last_runtime);
                      id(heater_runtime_start) = 0;
                      ESP_LOGI("heater", "Heater turned off. This session time: %lu ms", id(heater_last_runtime));
                    }

                    if (id(heater_waiting_for_idle)) {
                      id(heater_cooldown_active) = false;
                      id(heater_waiting_for_idle) = false;
                      ESP_LOGI("heater", "Cooldown period ENDED - heater cooled down! Can now turn on.");
                    }

                    ESP_LOGI("vevor", "Heater is IDLE (0x%04X)", val);
                  } else {
                    id(heater_idle_status) = false;
                    id(led_heater_on) = true;

                    if (id(heater_runtime_start) == 0) {
                      id(heater_runtime_start) = millis();
                      ESP_LOGI("heater", "Heater turned on. Starting runtime timer");
                    }

                    if ((val & 0xF000) == 0x9000) {
                      uint8_t last_nibble = val & 0x000F;

                      switch(last_nibble) {
                        case 0xA:
                          id(heater_power_level) = 6;
                          id(heater_power_letter) = "A";
                          break;
                        case 0xB:
                          id(heater_power_level) = 5;
                          id(heater_power_letter) = "B";
                          break;
                        case 0xC:
                          id(heater_power_level) = 4;
                          id(heater_power_letter) = "C";
                          break;
                        case 0xD:
                          id(heater_power_level) = 3;
                          id(heater_power_letter) = "D";
                          break;
                        case 0xE:
                          id(heater_power_level) = 2;
                          id(heater_power_letter) = "E";
                          break;
                        case 0xF:
                          id(heater_power_level) = 1;
                          id(heater_power_letter) = "F";
                          break;
                        default:
                          id(heater_power_level) = 0;
                          id(heater_power_letter) = "N/A";
                          break;
                      }
                      ESP_LOGI("vevor", "Heater is ACTIVE (0x%04X), power level: %s (%d)",
                              val, id(heater_power_letter).c_str(), id(heater_power_level));
                    } else {
                      id(heater_power_level) = 0;
                      id(heater_power_letter) = "N/A";
                      ESP_LOGI("vevor", "Heater is ACTIVE (0x%04X)", val);
                    }
                  }

                  uint32_t uptime_seconds = millis() / 1000;
                  char uptime_str[25];
                  snprintf(uptime_str, sizeof(uptime_str), "Uptime: %02lu:%02lu:%02lu",
                           uptime_seconds / 3600, (uptime_seconds % 3600) / 60, uptime_seconds % 60);
                  id(last_16bit_timestamp) = std::string(uptime_str);
                }
              }
            });

            id(vevor_init_flag) = true;
          }

  - interval: 1s
    then:
      - lambda: |-
          uint32_t now = millis();
          bool should_led_be_on = false;
          static uint32_t last_blink_time = 0;
          static bool blink_state = false;

          if (id(heater_cooldown_active)) {
            if (now - last_blink_time >= 250) {
              blink_state = !blink_state;
              last_blink_time = now;
            }
            should_led_be_on = blink_state;
          }
          else {
            if (id(last_heater_comms_time) != 0 && (now - id(last_heater_comms_time) < 5000)) {
              if (id(last_16bit_value) != 0 && !((id(last_16bit_value) & 0xFFF0) == 0x9FF0 || id(last_16bit_value) == 0xfa6c || id(last_16bit_value) == 0x7ffd || (id(last_16bit_value) & 0xF000) == 0x7000)) {
                should_led_be_on = true;
              }
            }
          }

          if (should_led_be_on) {
            id(heater_status_led).turn_on();
          } else {
            id(heater_status_led).turn_off();
          }

  - interval: 5s
    then:
      - lambda: |-
          if (id(heater_cooldown_active) && (millis() - id(heater_cooldown_start) >= id(heater_cooldown_duration))) {
            id(heater_cooldown_active) = false;
            ESP_LOGI("heater", "Cooldown period ended (%lu seconds)",
                     id(heater_cooldown_duration) / 1000);
          }

script:
  - id: send_loop
    mode: restart
    then:
      - if:
          condition:
            lambda: 'return id(auto_tx_active);'
          then:
            - lambda: |-
                if (id(one_shot_bit2)) {
                  id(original_bit2_state) = id(bit2).state;
                  id(bit2).turn_on();
                }
                if (id(one_shot_bit1)) {
                  id(original_bit1_state) = id(bit1).state;
                  id(bit1).turn_on();
                }
            - button.press: send_heater_packet
            - lambda: |-
                delay(50);

                if (id(one_shot_bit2)) {
                  if (!id(original_bit2_state)) {
                    id(bit2).turn_off();
                  }
                  id(one_shot_bit2) = false;
                  ESP_LOGI("vevor", "One-shot bit2 cycle completed");
                }

                if (id(one_shot_bit1)) {
                  if (!id(original_bit1_state)) {
                    id(bit1).turn_off();
                  }
                  id(one_shot_bit1) = false;
                  ESP_LOGI("vevor", "One-shot bit1 cycle completed");
                }
            - delay: !lambda 'return id(auto_tx_interval) * 1000;'
            - script.execute: send_loop

binary_sensor:
  - platform: gpio
    pin:
      number: GPIO13
      mode: INPUT_PULLUP
      inverted: true
    name: "Button GPIO13 (on/off)"
    on_multi_click:
      # ---- SHORT CLICK ----
      - timing:
          - ON for 50ms to 2s
        then:
          - button.press: power_one_shot_toggle
          - lambda: |-
              ESP_LOGI("button", "Short click - power_one_shot_toggle");
          
  - platform: gpio
    name: "MQ-2 Gas (digital out)"
    pin:
      number: GPIO33
      mode: INPUT
      inverted: true
    device_class: gas

  - platform: gpio
    id: vevor_rx_reserve
    pin:
      number: 16
      mode: INPUT_PULLDOWN

  - platform: template
    name: "Heater On Status"
    id: heater_on_status
    lambda: |-
      uint32_t now = millis();
      if (id(last_heater_comms_time) == 0 || (now - id(last_heater_comms_time) >= 5000)) {
        return false;
      }
      return !id(heater_idle_status);
    filters:
      - delayed_off: 2s

  - platform: template
    name: "Heater Cooldown Status"
    id: heater_cooldown_status
    lambda: |-
      return id(heater_cooldown_active);

  - platform: template
    name: "Heater Fault Status"
    id: heater_fault_status
    lambda: |-
      uint16_t val = id(last_16bit_value);
      return (val == 0x7ffd || (val & 0xF000) == 0x7000);
    filters:
      - delayed_off: 2s

switch:
  - platform: template
    id: bit7
    name: "Transmit Bit 1"
    optimistic: true
    restore_mode: ALWAYS_OFF

  - platform: template
    id: bit6
    name: "Transmit Bit 2"
    optimistic: true
    restore_mode: ALWAYS_ON

  - platform: template
    id: bit5
    name: "Transmit Bit 3"
    optimistic: true
    restore_mode: ALWAYS_OFF

  - platform: template
    id: bit4
    name: "Transmit Bit 4"
    optimistic: true
    restore_mode: ALWAYS_ON

  - platform: template
    id: bit3
    name: "Transmit Bit 5"
    optimistic: true
    restore_mode: ALWAYS_ON

  - platform: template
    id: bit2
    name: "Transmit Bit 6 (On/Off)"
    optimistic: true
    restore_mode: ALWAYS_OFF

  - platform: template
    id: bit1
    name: "Transmit Bit 7 (Power Level)"
    optimistic: true
    restore_mode: ALWAYS_OFF

  - platform: template
    id: bit0
    name: "Transmit Bit 8"
    optimistic: true
    restore_mode: ALWAYS_ON

  - platform: template
    name: "TX Operation"
    id: auto_tx_active_switch
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    lambda: 'return id(auto_tx_active);'
    turn_on_action:
      - lambda: |-
          id(auto_tx_active) = true;
          id(last_comms_time) = 0;
          id(last_heater_comms_time) = 0;
      - script.execute: send_loop
    turn_off_action:
      - lambda: |-
          id(auto_tx_active) = false;
          id(last_comms_time) = 0;
          id(last_heater_comms_time) = 0;

  - platform: template
    name: "Heater"
    id: heater_control_switch
    optimistic: true
    restore_mode: ALWAYS_OFF
    icon: "mdi:heater"
    lambda: |-
      uint32_t now = millis();
      if (id(last_heater_comms_time) == 0 || (now - id(last_heater_comms_time) >= 5000)) {
        return false;
      }
      return !id(heater_idle_status);
    turn_on_action:
      then:
        - lambda: |-
            uint32_t now = millis();
            if (id(last_heater_comms_time) == 0 || (now - id(last_heater_comms_time) >= 5000)) {
              ESP_LOGW("heater", "Cannot turn on - no communication");
              return;
            }
            if (!id(heater_idle_status)) {
              ESP_LOGW("heater", "Cannot turn on - heater is already on");
              return;
            }
            if (id(heater_cooldown_active)) {
              ESP_LOGW("heater", "Cannot turn on - active cooldown period");
              return;
            }
            if (id(heater_waiting_for_idle)) {
              ESP_LOGW("heater", "Cannot turn on - waiting for heater to return to IDLE state");
              return;
            }
            if ((now - id(heater_last_toggle_time)) < 5000) {
              ESP_LOGW("heater", "Cannot turn on - already toggled in last 5 seconds");
              return;
            }
            ESP_LOGI("heater", "Turning on heater");
            id(one_shot_bit2) = true;
            id(heater_last_toggle_time) = millis();
    turn_off_action:
      then:
        - lambda: |-
            uint32_t now = millis();
            if (id(last_heater_comms_time) == 0 || (now - id(last_heater_comms_time) >= 5000)) {
              ESP_LOGW("heater", "Cannot turn off - no communication");
              return;
            }
            if (id(heater_idle_status)) {
              ESP_LOGW("heater", "Cannot turn off - heater is already off");
              return;
            }
            if (id(heater_cooldown_active)) {
              ESP_LOGW("heater", "Cannot turn off - active cooldown period");
              return;
            }
            if ((now - id(heater_last_toggle_time)) < 5000) {
              ESP_LOGW("heater", "Cannot turn off - already toggled in last 5 seconds");
              return;
            }
            ESP_LOGI("heater", "Turning off heater");
            id(one_shot_bit2) = true;
            id(heater_last_toggle_time) = millis();
            id(heater_cooldown_active) = true;
            id(heater_cooldown_start) = millis();
            id(heater_waiting_for_idle) = true;
            ESP_LOGI("heater", "Started cooldown period (%lu seconds). Waiting for IDLE state (0x9FFX)...",
                     id(heater_cooldown_duration) / 1000);

button:
  - platform: template
    name: "Turn Heater On (single cycle)"
    id: heater_one_shot_toggle
    on_press:
      then:
        - lambda: |-
            id(one_shot_bit2) = true;
            ESP_LOGI("vevor", "One-shot bit2 activated - bit2 will be ON next cycle");

  - platform: template
    name: "Power Toggle (single cycle)"
    id: power_one_shot_toggle
    on_press:
      then:
        - lambda: |-
            id(one_shot_bit1) = true;
            ESP_LOGI("vevor", "One-shot bit1 activated - bit1 will be ON next cycle");

  - platform: restart
    name: "Restart Controller"

  - platform: template
    name: "Send Data Packet"
    id: send_heater_packet
    on_press:
      then:
        - lambda: |-
            uint8_t b = 0;
            b |= id(bit7).state ? 0x80 : 0;
            b |= id(bit6).state ? 0x40 : 0;
            b |= id(bit5).state ? 0x20 : 0;
            b |= id(bit4).state ? 0x10 : 0;
            b |= id(bit3).state ? 0x08 : 0;
            b |= id(bit2).state ? 0x04 : 0;
            b |= id(bit1).state ? 0x02 : 0;
            b |= id(bit0).state ? 0x01 : 0;

            if (b != id(last_8bit_value)) {
              id(last_8bit_value) = b;
              uint32_t uptime_seconds = millis() / 1000;
              char uptime_str[25];
              snprintf(uptime_str, sizeof(uptime_str), "Uptime: %02lu:%02lu:%02lu",
                       uptime_seconds / 3600, (uptime_seconds % 3600) / 60, uptime_seconds % 60);
              id(last_8bit_timestamp) = std::string(uptime_str);
            }

            ESP_LOGI("vevor", "Sent byte 0x%02X", b);
            vevor_send_byte(b);

  - platform: template
    name: "Test LED"
    id: test_led_button
    on_press:
      then:
        - lambda: |-
            ESP_LOGI("test", "LED test started");
        - output.turn_on: heater_status_led
        - delay: 500ms
        - output.turn_off: heater_status_led
        - delay: 500ms
        - output.turn_on: heater_status_led
        - delay: 500ms
        - output.turn_off: heater_status_led
        - lambda: |-
            ESP_LOGI("test", "LED test completed");

  - platform: template
    name: "Reset Total Runtime"
    id: reset_total_runtime
    on_press:
      then:
        - lambda: |-
            ESP_LOGI("heater", "Reset total runtime");
            id(heater_total_runtime) = 0;
            id(heater_last_runtime) = 0;

number:
  - platform: template
    name: "Send Interval (s)"
    id: send_interval_number
    min_value: 1
    max_value: 10.0
    step: 0.5
    optimistic: true
    unit_of_measurement: "s"
    set_action:
      - lambda: 'id(auto_tx_interval) = x;'

  - platform: template
    name: "Cooldown Time"
    id: heater_cooldown_duration_number
    min_value: 180
    max_value: 720
    step: 10
    optimistic: true
    unit_of_measurement: "s"
    icon: "mdi:timer-sand"
    set_action:
      - lambda: 'id(heater_cooldown_duration) = x * 1000;'
      
one_wire:
  - platform: gpio
    pin: GPIO4
    
sensor:
  - platform: dallas_temp
    name: "DS18B20 Temperature"
    update_interval: 10s

  - platform: template
    name: "Battery Voltage (standby only)"
    id: battery_voltage
    unit_of_measurement: "V"
    accuracy_decimals: 2
    icon: "mdi:car-battery"
    device_class: voltage
    state_class: measurement
    update_interval: 1s
    lambda: |-
      uint16_t val = id(last_16bit_value);
      if ((val & 0xFFF0) == 0x9FF0) {
        switch (val & 0x000F) {
          case 0x0:
            return 15.0;
          case 0x1:
            return 14.2;
          case 0x2:
            return 12.75;
          case 0x3:
            return 12.2;
          case 0x4:
            return 11.8;
          case 0x5:
            return 11.0;
          case 0x6:
            return 10.0;                        
          default:
            return NAN;
        }
      }
      return NAN;

  - platform: adc
    pin: GPIO36
    name: "MQ-2 Gas (analog out)"
    id: smk
    update_interval: 20s
    attenuation: auto
    unit_of_measurement: "V"
    icon: "mdi:percent"

  - platform: template
    name: "Remaining Cooldown Time"
    id: heater_cooldown_remaining
    lambda: |-
      if (!id(heater_cooldown_active)) {
        return 0;
      }
      uint32_t now = millis();
      uint32_t elapsed = now - id(heater_cooldown_start);
      if (elapsed >= id(heater_cooldown_duration)) {
        return 0;
      }
      return (id(heater_cooldown_duration) - elapsed) / 1000;
    unit_of_measurement: "s"
    accuracy_decimals: 0
    update_interval: 10s
    icon: "mdi:timer-sand"

  - platform: template
    name: "Heater Current Session Time"
    id: heater_current_session_time
    lambda: |-
      if (id(heater_runtime_start) == 0) {
        return 0;
      }
      return (millis() - id(heater_runtime_start)) / 1000;
    unit_of_measurement: "s"
    accuracy_decimals: 0
    update_interval: 10s
    icon: "mdi:timer"
    device_class: duration

  - platform: template
    name: "Heater Total Runtime"
    id: heater_total_runtime_sensor
    lambda: |-
      uint32_t total = id(heater_total_runtime);
      if (id(heater_runtime_start) != 0) {
        total += (millis() - id(heater_runtime_start));
      }
      return total / 1000;
    unit_of_measurement: "s"
    accuracy_decimals: 0
    update_interval: 30s
    icon: "mdi:timer-outline"
    device_class: duration

  - platform: template
    name: "ESP32 PWM Communication Status"
    id: comms_status
    lambda: |-
      uint32_t now = millis();
      if (id(last_comms_time) != 0 && (now - id(last_comms_time) < 5000)) {
        return 1;
      } else {
        return 0;
      }
    update_interval: 5s

  - platform: template
    name: "Heater Communication Status"
    id: heater_comms_status
    lambda: |-
      uint32_t now = millis();
      if (id(last_heater_comms_time) != 0 && (now - id(last_heater_comms_time) < 5000)) {
        return 1;
      } else {
        return 0;
      }
    update_interval: 5s

  - platform: template
    name: "Heater Power Level"
    id: heater_power_level_sensor
    lambda: 'return id(heater_power_level);'
    update_interval: 5s
    unit_of_measurement: "lvl"
    accuracy_decimals: 0

  - platform: wifi_signal
    name: "Wi-Fi Signal Strength"
    id: wifi_signal_strength
    update_interval: 60s

  - platform: uptime
    name: "Uptime"
    id: uptime_seconds
    update_interval: 60s
    unit_of_measurement: "s"
    accuracy_decimals: 0

text_sensor:
  - platform: template
    name: "Last Received 16-bit Value (binary)"
    id: last_received_16bit_bin
    lambda: |-
      char buffer[17] = {0};
      for (int i = 0; i < 16; i++) {
        buffer[i] = (id(last_16bit_value) & (1 << (15 - i))) ? '1' : '0';
      }
      return std::string(buffer);
    update_interval: 1s

  - platform: template
    name: "Last Sent 8-bit Value"
    id: last_sent_8bit_hex
    lambda: |-
      char buffer[16];
      snprintf(buffer, sizeof(buffer), "0x%02X", id(last_8bit_value));
      return std::string(buffer);
    update_interval: 1s

  - platform: template
    name: "Last Sent 8-bit Value (binary)"
    id: last_sent_8bit_bin
    lambda: |-
      char buffer[9] = {0};
      for (int i = 0; i < 8; i++) {
        buffer[i] = (id(last_8bit_value) & (1 << (7 - i))) ? '1' : '0';
      }
      return std::string(buffer);
    update_interval: 1s

  - platform: template
    name: "Last Received 16-bit Value"
    id: last_received_16bit_hex
    lambda: |-
      char buffer[16];
      snprintf(buffer, sizeof(buffer), "0x%04X", id(last_16bit_value));
      return std::string(buffer);
    update_interval: 1s

  - platform: template
    name: "Last 8-bit Value Change"
    id: last_8bit_timestamp_sensor
    lambda: |-
      static uint8_t last_logged_value = 0;
      if (id(last_8bit_value) != last_logged_value) {
        last_logged_value = id(last_8bit_value);
        uint32_t uptime_seconds = millis() / 1000;
        char buffer[25];
        snprintf(buffer, sizeof(buffer), "Uptime: %02lu:%02lu:%02lu",
                 uptime_seconds / 3600, (uptime_seconds % 3600) / 60, uptime_seconds % 60);
        return std::string(buffer);
      }
      return std::string("");

  - platform: template
    name: "Last 16-bit Value Change"
    id: last_16bit_timestamp_sensor
    lambda: |-
      if (id(last_16bit_value) == 0) {
        return std::string("");
      }
      uint32_t now = millis();
      static uint16_t last_logged_value = 0;
      if (id(last_16bit_value) != last_logged_value) {
        last_logged_value = id(last_16bit_value);
        uint32_t uptime_seconds = millis() / 1000;
        char buffer[25];
        snprintf(buffer, sizeof(buffer), "Uptime: %02lu:%02lu:%02lu",
                 uptime_seconds / 3600, (uptime_seconds % 3600) / 60, uptime_seconds % 60);
        return std::string(buffer);
      }
      return std::string("");

  - platform: template
    name: "ESP32 Boot Time"
    id: boot_time_sensor
    lambda: |-
      uint32_t uptime_seconds = millis() / 1000;
      char buffer[30];
      snprintf(buffer, sizeof(buffer), "Uptime: %02lu:%02lu:%02lu",
               uptime_seconds / 3600, (uptime_seconds % 3600) / 60, uptime_seconds % 60);
      return std::string(buffer);
    update_interval: 10s

  - platform: template
    name: "Heater Status"
    id: heater_status_text
    update_interval: 5s
    lambda: |-
      uint32_t now = millis();
      uint16_t val = id(last_16bit_value);

      if (id(last_heater_comms_time) == 0 || (now - id(last_heater_comms_time) >= 5000)) {
        return std::string("NO COMMUNICATION");
      }

      if ((val & 0xFFF0) == 0x9FF0 || val == 0xfa6c || val == 0x7ffd || (val & 0xF000) == 0x7000) {
        return std::string("COOLED DOWN");
      }

      if (val == 0x933F) {
        return std::string("TURNING OFF");
      }
      if (val == 0x963F) {
        return std::string("FLAME CLEARING");
      }
      if (val == 0x973F) {
        return std::string("COOLING DOWN");
      }

      if (val == 0x97BA || val == 0x96BA || val == 0x92BA) {
        return std::string("STARTING UP");
      }

      if ((val & 0xFF00) == 0x9300) {
        uint8_t nibble = val & 0x000F;
        if (nibble >= 0x0A && nibble <= 0x0F) {
          char power = 'A' + (nibble - 0x0A);
          return std::string("OPERATION â€“ POWER ") + power;
        }
        return std::string("OPERATION");
      }

      return std::string("UNKNOWN");

  - platform: template
    name: "Heater Control Status"
    id: heater_control_status
    lambda: |-
      uint32_t now = millis();
      uint16_t val = id(last_16bit_value);

      if (id(last_heater_comms_time) == 0 || (now - id(last_heater_comms_time) >= 5000)) {
        return std::string("NO COMMUNICATION");
      }

      if (id(heater_cooldown_active)) {
        uint32_t remaining = 0;
        if (id(heater_cooldown_duration) > (now - id(heater_cooldown_start))) {
          remaining = (id(heater_cooldown_duration) - (now - id(heater_cooldown_start))) / 1000;
        }
        char buffer[40];
        snprintf(buffer, sizeof(buffer), "COOLING DOWN (%lus)", remaining);
        return std::string(buffer);
      }

      if (id(heater_waiting_for_idle)) {
        return std::string("WAITING FOR COOLDOWN");
      }

      if ((now - id(heater_last_toggle_time)) < 5000) {
        return std::string("WAITING");
      }

      if ((val & 0xFFF0) == 0x9FF0 || val == 0xfa6c || val == 0x7ffd || (val & 0xF000) == 0x7000) {
        return std::string("READY TO TURN ON");
      } else {
        return std::string("READY TO TURN OFF");
      }
    update_interval: 5s
